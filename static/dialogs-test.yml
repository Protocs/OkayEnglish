--- !Choices
name: START  # Первое состояние всегда называется START
text:
  - Здравствуйте! Это мы, хороводоведы. &(Здравствуйте! Это мы, хоров+одо в+еды.)  # &(...) - измененное произношение
  - Ауе
choices:
  - !Choice
    hint: Даааааа чи да
    match: да  # Регулярное выражение выбора. Если оно совпадает с ответом пользователя, выбирается этот вариант
    next: chi-da
  - !Choice
    hint: Ниме
    match: н[еи]
    next: fuck_off

    # Ответ "Не поняла", наподобие default в switch в С++
  - !Choice
    # hint отсутствует, подсказка не показывается
    match: .*
    next: START
    # prepend_next_answer добавляет текст в начале сообщения следующего состояния.
    # К примеру, в этом случае Алиса скажет:
    # ---
    # Ты чо гонишь чтоли или чо, я не поняла / Кавоооо ты сказал
    # Здравствуйте! Это мы, хороводоведы. / Ауе
    # ---
    prepend_next_answer:
      - Ты чо гонишь чтоли или чо, я не поняла
      - Кавоооо ты сказал

--- !Input
name: chi-da
text: Куда надо
# Пример next, выбираемый функцией
# В состоянии Input в функцию передается переменная "inp" с введенным текстом
# Функция должна возвратить название состояния, в которое надо перейти
next: |
  code
  return inp

--- !Input
name: scream
text: Даваи я поору. Введи текст, я сделаю его большим
next: |
  code
  # Пример обращения к хранилищу сессии (storage)
  # Это как словарь, к которому можно обращаться и через "[]", и через ".".
  # Следующие 2 строки делают одно и то же
  storage.scream_text = inp
  storage["scream_text"] = inp
  return "scream_out"

--- !Choices
name: scream_out
# Текст сообщения, вычисляемое функцией
text: |
  code
  return storage.scream_text.upper() + "\nГромко ору?"
choices:
  - !Choice
    text: Да
    match: да
    next: thanks
  - !Choice
    text: Нет
    match: не
    next: fuck_off

# Конечное состояние: Алиса прощается с пользователем и происходитвыход из навыка
--- !Exit
name: fuck_off
text: Ну и иды нафик
